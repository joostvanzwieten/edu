'use strict';

var op_add = '+';
var op_sub = '\u2212';
var op_mul = '\xD7';
var op_div = ':';

// Pick a random integer from [a,b).
function randrange(a, b)
{
  if (!(a < b))
    throw 'ERROR: empty range: a=' + a + ', c=' + c + '.';
  let number = Math.floor(Math.random() * (b - a) + a);
  if (number >= b)
    number = b - 1;
  return number;
}

// Pick a random element from `options`.
function random_choice(options)
{
  if (options.length == 0)
    throw 'ERROR: `options` should have at least one element.'
  return options[randrange(0, options.length)];
}

// Parse a multirange string and return the length and a list of ranges, where
// a range is an object with attributes 'a', the start of the range, 'b', the
// end point of the range (included) and 'n', the length of the range.  The
// argument `multirange_string` is a comma-separated list of single numbers or
// ranges (start + ':' + stop), strictly increasing.  If the start or stop
// point of a ranges is omitted, this implies minux or positive infinity,
// respectively.
//
// Example: '1:3,5' defines the set {1, 2, 3, 5}, '0:' defines all
// non-negative integers.
function parse_multirange_string(multirange_string)
{
  let ranges = [];
  let size = 0;
  let position = -Infinity;
  if (multirange_string.trim().length == 0)
    size = Infinity;
  else
    for (let element of multirange_string.split(','))
    {
      let parts = element.split(':');
      if (element.trim().length == 0)
        throw 'ERROR: Empty range part.  Trialing comma?'
      else if (parts.length == 1)
      {
        let a = parseInt(parts[0]);
        if (!Number.isInteger(a))
          throw 'ERROR: Not a number: "' + parts[0] + '"';
        if (a <= position)
          throw 'ERROR: Ranges are not strictly increasing.';
        ranges.push({a: a, b: a + 1, n: 1});
        size += 1;
        position = a;
      }
      else if (parts.length == 2)
      {
        let a = parseInt(parts[0]);
        if (parts[0].trim().length == 0)
          a = -Infinity;
        else if (!Number.isInteger(a))
          throw 'ERROR: Not a number: ' + parts[0];
        if (a <= position)
          throw 'ERROR: Ranges are not strictly increasing.';
        let b = parseInt(parts[1]);
        if (parts[1].trim().length == 0)
          b = Infinity;
        else if (!Number.isInteger(b))
          throw 'ERROR: Not a number: ' + parts[1];
        if (b <= a)
          throw 'ERROR: The end point of range should be larger than the start point: ' + element;
        let n = b - a + 1;
        size += n;
        ranges.push({a: a, b: b, n: n});
        position = b;
      }
      else
        throw 'ERROR: Cannot parse range: ' + element;
    }
  return {n: size, ranges: ranges};
}

// Pick a random integer from the set of ranges specified by `multirange`: an
// array of ranges generated by `parse_multirange_string`.
function random_multirange(multirange)
{
  if (multirange.n == Infinity)
    throw 'INTERNAL ERROR: Random_multirange called with indefinite range.';
  // Pick a random integer from [0, `multirange.n`) and map to
  // `multirange.ranges`.
  let index = randrange(0, multirange.n);
  for (let part of multirange.ranges)
    if (index < part.n)
      return part.a + index;
    else
      index -= part.n;
  throw 'INTERNAL ERROR';
}

// Verify `value` is in `multirange`.
function is_in_multirange(value, multirange)
{
  if (!Number.isInteger(value))
    return false;
  if (multirange.ranges.length == 0)
    return true;
  for (let range of multirange.ranges)
    if (range.a <= value && value <= range.b)
      return true;
  return false;
}

// Create an element.  The attributes 'classes', 'children' and 'events' of
// kwargs are parsed, the remainder is applied as attribute to the element.
function create_element(tag, kwargs)
{
  // TODO: Allow multiple handlers for the same event.
  let element = document.createElement(tag);
  if (kwargs === undefined)
    return element;
  for (let key in kwargs)
    if (key == 'classes' || key == 'children' || key == 'events' || key == 'dataset')
      ;
    else if (kwargs.hasOwnProperty(key))
    {
      if (key == 'innerHTML')
        element[key] = kwargs[key];
      else
        element.setAttribute(key, kwargs[key]);
    }
  if (kwargs.classes)
    for (let cls of kwargs.classes)
      element.classList.add(cls);
  if (kwargs.events)
    for (let e of kwargs.events)
    {
      let func = e.func;
      if (e.bind)
        func = func.bind(element);
      element.addEventListener(e.name, func);
    }
  if (kwargs.dataset)
    for (let attr in kwargs.dataset)
      if (kwargs.dataset.hasOwnProperty(attr))
        element.dataset[attr] = kwargs.dataset[attr];
  if (kwargs.children)
    for (let child of kwargs.children)
    {
      if (typeof(child) == 'string')
        child = document.createTextNode(child);
      element.appendChild(child);
    }
  return element;
}

// Create an editable span.  The attribute 'value' of `kwargs` controls the
// initial value of the input element.  The remaining attributes are applied
// to the outermost element.
function create_input_element(kwargs)
{
  if (!kwargs.events)
    kwargs.events = [];
  kwargs.events.push({name: 'keypress', func: input_keypress_handler, bind: true});
  kwargs.events.push({name: 'focusin', func: input_focus_handler, bind: true});
  let value = kwargs.value;
  delete kwargs.value;
  if (value === undefined)
    value = '';
  kwargs.contenteditable = true;
  kwargs.children = [value];
  return create_element('span', kwargs);
}

// Create a multirange element.  This is an input element with instant sanity
// check.
function create_multirange_element(kwargs)
{
  if (!kwargs.events)
    kwargs.events = [];
  kwargs.events.push({name: 'input', func: multirange_changed_handler, bind: true});
  return create_input_element(kwargs);
}

// Event handler for changed events of multirange input elements.  Checks
// validity of input.
function multirange_changed_handler()
{
  try
  {
    parse_multirange_string(this.innerText);
    this.classList.remove('invalid');
  }
  catch (e)
  {
    this.classList.add('invalid');
  }
}

// Event handler for focus events of input elements.  Selects all text when the
// element gets focus.
function input_focus_handler()
{
  // Based on http://jsfiddle.net/rudiedirkx/MgASG/1/ .
  requestAnimationFrame((function()
  {
    let range = document.createRange();
    range.selectNodeContents(this);
    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }).bind(this));
}

// Event handler for keypress events.  Disables 'Enter'.
function input_keypress_handler(e)
{
  if (e.key == 'Enter')
  {
    // Prevent line breaks.
    e.preventDefault();
    e.stopPropagation();
  }
}

// Create a checkbox.  The attribute 'selected' of `kwargs` controls the
// initial state of the checkbox and should be `true` or `false`.  The
// remaining attributes are applied to the outermost element.
function create_checkbox(kwargs)
{
  if (!kwargs.classes)
    kwargs.classes = [];
  kwargs.classes.push('checkbox');
  if (kwargs.selected)
    kwargs.classes.push('selected');
  delete kwargs.selected;
  if (!kwargs.events)
    kwargs.events = [];
  kwargs.events.push({name: 'click', func: toggle_checkbox, bind: true});
  kwargs.children = ['[', create_element('span', {children: ['x']}), ']'];
  return create_element('span', kwargs);
}

// Toggle checkbox.  `this` should point to the checkbox element.  Used as
// event handler.
function toggle_checkbox(e)
{
  e.stopPropagation();
  e.preventDefault();
  this.classList.toggle('selected');
  this.dispatchEvent(new Event('change', {bubbles: true}));
}

var n_option_groups = 0;

function allocate_option_group()
{
  n_option_groups += 1;
  return n_option_groups;
}

function create_option(kwargs)
{
  if (!kwargs.classes)
    kwargs.classes = [];
  kwargs.classes.push('option');
  kwargs.classes.push('optiongroup-' + kwargs.group);
  delete kwargs.group;
  if (kwargs.selected)
    kwargs.classes.push('selected');
  delete kwargs.selected;
  if (!kwargs.events)
    kwargs.events = [];
  kwargs.events.push({name: 'click', func: select_option, bind: true});
  kwargs.children = ['(', create_element('span', {children: ['x']}), ')'];
  return create_element('span', kwargs);
}

// Select option.  `this` should point to the option element.  Used as event
// handler.
function select_option(e)
{
  e.stopPropagation();
  e.preventDefault();
  // Remove selection from other options in the same group.
  for (let cls of this.classList)
  {
    if (cls.startsWith('optiongroup-'))
      for (let el of document.getElementsByClassName(cls))
        el.classList.remove('selected');
  }
  // Select this option.
  this.classList.add('selected');
  this.dispatchEvent(new Event('change', {bubbles: true}));
}

// Show or hide answers based on checkbox state.  `this` should point to the
// checkbox element.  Used as event handler.
function update_show_answers(e)
{
  if (this.classList.contains('selected'))
    document.getElementById('worksheet').classList.add('showanswers');
  else
    document.getElementById('worksheet').classList.remove('showanswers');
  // Stop propagation.  Otherwise the body event handler would wipe the screen
  // unnecessarily.
  e.stopPropagation();
}

// Create a button.  The contents of the buttons should be passed via the
// 'children' attribute of `kwargs`.  A clicked callback should be set via the
// 'click' attribute of the 'events' attribute of `kwargs`, e.g.
//
//     create_button({children: ['text'], events: [{name: 'click', func: function()
//     {
//         window.alert('clicked');
//     }}]);
function create_button(kwargs)
{
  if (!kwargs.classes)
    kwargs.classes = [];
  kwargs.classes.push('button');
  return create_element('span', kwargs);
}

// Apply operator `op`, one of op_{add,sub,mul,div}, with `l` and `r` as
// left and right operands, respectively.
function apply_operator(op, l, r)
{
  if (op == op_add)
    return l + r;
  else if (op == op_sub)
    return l - r;
  else if (op == op_mul)
    return l * r;
  else if (op == op_div)
    return l / r;
  throw 'ERROR: Unknown operator: "' + op + '".';
}

// Generate random left, right and right hand side values and operator symbol
// as an object with attributes `l`, `r`, `rhs` and `operator`, respectively,
// for the specified exercise `type`.
function generate_exercise(settings)
{
  // Parse multirange strings.
  let parsed_settings = {};
  for (let v of ['a', 'b', 'c'])
    parsed_settings[v] = parse_multirange_string(settings[v]);
  // Use variables with the smallest two multiranges for random selection.
  let vars = ['a', 'b', 'c'].sort(function(l, r) { return parsed_settings[l].n - parsed_settings[r].n });
  // Sort `vars` to use multiplication instead of division when posible.
  if (parsed_settings.a.n != Infinity && parsed_settings.b.n != Infinity && parsed_settings.c.n != Infinity)
  {
    if (settings.operator == op_mul)
      vars = ['a', 'b', 'c'];
    else if (settings.operator == op_div)
      vars = ['b', 'c', 'a'];
  }
  // Assert the first two multiranges of `vars` are definite.
  if (parsed_settings[vars[0]].n == Infinity || parsed_settings[vars[1]].n == Infinity)
    throw 'ERROR: An exercise requires at least two variables with a definite range.'
  // Pick random numbers.  Try one thousand times to match additional
  // conditions.
  for (let i = 0; i < 1000; i++)
  {
    // Pick random numbers for the first two variables.
    let x = [
      random_multirange(parsed_settings[vars[0]]),
      random_multirange(parsed_settings[vars[1]]),
    ];
    // Compute remainig variable.
    if (vars[2] == 'c')
    {
      if (vars[0] == 'a')
        x.push(apply_operator(settings.operator, x[0], x[1]));
      else
        x.push(apply_operator(settings.operator, x[1], x[0]));
    }
    else if (vars[2] == 'b')
    {
      let alt_ops = {};
      alt_ops[op_add] = op_sub;
      alt_ops[op_sub] = op_sub;
      alt_ops[op_mul] = op_div;
      alt_ops[op_div] = op_div;
      let alt_op = alt_ops[settings.operator];
      let reverse = settings.operator == op_add || settings.operator == op_mul;
      if (vars[0] == 'c')
        reverse = !reverse;
      if (reverse)
        x.push(apply_operator(alt_op, x[1], x[0]));
      else
        x.push(apply_operator(alt_op, x[0], x[1]));
    }
    else if (vars[2] == 'a')
    {
      let inv_ops = {};
      inv_ops[op_add] = op_sub;
      inv_ops[op_sub] = op_add;
      inv_ops[op_mul] = op_div;
      inv_ops[op_div] = op_mul;
      let inv_op = inv_ops[settings.operator];
      if (vars[0] == 'b')
        x.push(apply_operator(inv_op, x[1], x[0]));
      else
        x.push(apply_operator(inv_op, x[0], x[1]));
    }
    // Verify same tens condition, if required.
    if (settings.two_largest_same_tens)
    {
      // Sort numbers `x` on value, ascending.
      let x_sorted = x.slice().sort(function(l, r) { return l - r; });
      if (Math.floor(x_sorted[1] / 10) != Math.floor(x_sorted[2] / 10))
        continue;
    }
    // Check validity of the third variable with supplied range.
    if (is_in_multirange(x[2], parsed_settings[vars[2]]))
    {
      // Valid!  Return generated values.
      let values = {
        operator: settings.operator,
        hidden: random_choice(settings.hidden),
      };
      for (let j = 0; j < 3; j++)
        values[vars[j]] = x[j];
      // Sanity check: apply a op b and compare with c.
      if (apply_operator(values.operator, values.a, values.b) != values.c)
        throw 'INTERNAL ERROR: ' + values.a + ' ' + values.operator + ' ' + values.b + ' != ' + values.c + '.';
      return values;
    }
  }
  throw 'ERROR: Failed to generate exercise ' + JSON.stringify(settings) + '.  Most likely the specified ranges and conditions are incompatible.';
}

function generate(e)
{
  e.stopPropagation();
  e.preventDefault();

  if (this.classList.contains('disabled'))
    return;

  try
  {
    // Clean old worksheet.
    let el_worksheet = document.getElementById('worksheet');
    el_worksheet.innerHTML = '';

    let settings = get_settings();

    // Read settings.
    let n_pages = parseInt(settings.n_pages);
    let n_exercises = parseInt(settings.n_exercises);
    let n_cols = parseInt(settings.n_columns);
    let n_exercises_per_box = 5;

    // Generate pages.
    let el_pages = [];
    for (let j = 0; j < n_pages; j++)
    {
      let el_page = create_element('div', {classes: ['page']});
      el_pages.push(el_page);

      let el_page2 = create_element('div', {classes: ['container']});
      el_page.appendChild(el_page2);
      el_page = el_page2;

      el_page.appendChild(create_element('div', {innerHTML: document.getElementById('headertext').innerHTML}));

      let el_table = create_element('table');
      el_page.appendChild(el_table);

      let el_row = null;
      for (let i = 0; i < n_exercises; i++)
      {
        if (i % (n_cols * n_exercises_per_box) == 0 && i > 0)
          // Create an empty row.
          el_table.appendChild(create_element('tr', {classes: ['space']}));

        if (i % n_cols == 0)
        {
          // Create a new row.
          el_row = create_element('tr');
          el_table.appendChild(el_row);
        }
        else
          // Add an empty column.
          el_row.appendChild(create_element('td', {classes: ['space']}));

        let exercise = generate_exercise(random_choice(settings.exercises));

        let append_number = function(number, hidden)
        {
          if (hidden)
          {
            el_row.appendChild(create_element('td', {children: [
              create_element('span', {classes: ['dots'], children: [
                create_element('span', {classes: ['answer'], children: ['' + number]}),
                create_element('span', {classes: ['entryspace', 'answerreplacement']})
              ]})
            ]}));
          }
          else
            el_row.appendChild(create_element('td', {classes: ['number'], children: ['' + number]}));
        };

        append_number(exercise.a, exercise.hidden == 'a');
        el_row.appendChild(create_element('td', {children: [exercise.operator]}));
        append_number(exercise.b, exercise.hidden == 'b');
        el_row.appendChild(create_element('td', {children: ['=']}));
        append_number(exercise.c, exercise.hidden == 'c');
      }
    }

    for (let el_page of el_pages)
      el_worksheet.appendChild(el_page);
  }
  catch (e)
  {
    window.alert(e);
    throw e;
  }
}

var int_attributes = [
  'n_exercises', 'n_columns', 'n_pages',
];

var rich_text_attributes = [
  'headertext',
];

function add_exercise(exercise, highlight)
{
  if (exercise == undefined)
    exercise = {a: '1:9', b: '1:9', c: '', operator: '+', hidden: ['c']};
  if (highlight == undefined)
    highlight = true;
  let operator_group = allocate_option_group();
  let el = create_element('li', {children: [
    create_element('p', {children: [
      'Operator: ',
      create_option({group: operator_group, classes: ['option-operator'], dataset: {label: op_add}, selected: exercise.operator == op_add}), ' ' + op_add + ', ',
      create_option({group: operator_group, classes: ['option-operator'], dataset: {label: op_sub}, selected: exercise.operator == op_sub}), ' ' + op_sub + ', ',
      create_option({group: operator_group, classes: ['option-operator'], dataset: {label: op_mul}, selected: exercise.operator == op_mul}), ' ' + op_mul + ', ',
      create_option({group: operator_group, classes: ['option-operator'], dataset: {label: op_div}, selected: exercise.operator == op_div}), ' ' + op_div + '.',
    ]}),
    create_element('p', {children: [
      'Range a: ', create_multirange_element({classes: ['range-a'], value: exercise.a}),
      ', b: ', create_multirange_element({classes: ['range-b'], value: exercise.b}),
      ', c: ', create_multirange_element({classes: ['range-c'], value: exercise.c}), '.',
    ]}),
    create_element('p', {children: [
      'Hide: ',
      create_checkbox({classes: ['hide-a'], selected: exercise.hidden.includes('a')}), ' a, ',
      create_checkbox({classes: ['hide-b'], selected: exercise.hidden.includes('b')}), ' b, ',
      create_checkbox({classes: ['hide-c'], selected: exercise.hidden.includes('c')}), ' c.',
    ]}),
    create_element('p', {children: [
      create_checkbox({classes: ['two-largest-same-tens'], selected: exercise.two_largest_same_tens}),
      ' The two largest numbers have the same tens (and hundreds, and thousands...).',
    ]}),
    create_element('p', {children: [
      create_button({events: [{name: 'click', func: remove_exercise, bind: true}], children: ['remove']})]}),
  ]});
  if (highlight)
  {
    el.classList.add('highlightable');
    el.classList.add('highlight');
    // Remove highlight after three seconds.
    window.setTimeout(remove_highlight.bind(el), 3000);
  }
  document.getElementById('exercises').appendChild(el);
  el.dispatchEvent(new Event('change', {bubbles: true}));
}

function remove_highlight()
{
  this.classList.remove('highlight');
}

function remove_exercise()
{
  // Find parent li element.
  let el = this;
  while (el)
  {
    if (el.tagName.toLowerCase() == 'li')
    {
      let el_parent = el.parentElement;
      el.remove();
      el_parent.dispatchEvent(new Event('change', {bubbles: true}));
    }
    el = el.parentElement;
  }
}

function show_examples()
{
  let el_overlay = create_element('div', {classes: ['overlay', 'settings']});
  el_overlay.appendChild(create_element('h1', {children: ['Example exercises']}));
  el_overlay.appendChild(create_element('p', {children: [
    create_button({events: [{name: 'click', func: function() {
      add_exercise({a: '1:9', b: '1:9', c: '0:', operator: op_sub, hidden: ['c'], two_largest_same_tens: false});
      remove_overlay.apply(el_overlay);
    }, bind: false}], children: ['add']}),
    'a - b = c, with a and b from 1 to 9 (including), c >= 0 and c is hidden.',
  ]}));
  el_overlay.appendChild(create_element('p', {children: [
    create_button({events: [{name: 'click', func: function() {
      add_exercise({b: '1:9', c: '1:9', a: '0:', operator: op_add, hidden: ['a'], two_largest_same_tens: false});
      remove_overlay.apply(el_overlay);
    }, bind: false}], children: ['add']}),
    'a + b = c, with b and c from 1 to 9 (including), a >= 0 and a is hidden.',
  ]}));
  el_overlay.appendChild(create_element('p', {children: [
    create_button({events: [{name: 'click', func: function() {
      add_exercise({a: '1:10', b: '5', c: '', operator: op_mul, hidden: ['c'], two_largest_same_tens: false});
      remove_overlay.apply(el_overlay);
    }, bind: false}], children: ['add']}),
    'a * b = c, with a from 1 to 10 (including), b equals 5 and c is hidden.',
  ]}));
  el_overlay.appendChild(create_element('p', {children: [
    create_button({events: [{name: 'click', func: function() {
      add_exercise({c: '1:10', b: '5', a: '', operator: op_div, hidden: ['b'], two_largest_same_tens: false});
      remove_overlay.apply(el_overlay);
    }, bind: false}], children: ['add']}),
    'a / b = c, with c from 1 to 10 (including) and b equals 5 and b is hidden.',
  ]}));
  el_overlay.appendChild(create_element('p', {children: [
    create_button({events: [{name: 'click', func: remove_overlay.bind(el_overlay), bind: false}], children: ['close']}),
  ]}));
  document.body.appendChild(el_overlay);
}

function remove_overlay()
{
  this.remove();
}

function get_settings()
{
  let settings = {version: 1, exercises: []};
  // Int elements.
  for (let attribute of int_attributes)
    settings[attribute] = document.getElementById(attribute).innerText;
  // Rich text attributes.
  for (let attribute of rich_text_attributes)
    settings[attribute] = document.getElementById(attribute).innerHTML;
  // Exercises.
  for (let child of document.getElementById('exercises').children)
  {
    let exercise = {
      hidden: [],
      two_largest_same_tens: child.getElementsByClassName('two-largest-same-tens')[0].classList.contains('selected'),
    };
    let option_operator = child.querySelector('.option-operator.selected');
    if (option_operator)
      exercise.operator = option_operator.dataset.label;
    for (let v of ['a', 'b', 'c'])
    {
      exercise[v] = child.getElementsByClassName('range-' + v)[0].innerText;
      if (child.getElementsByClassName('hide-' + v)[0].classList.contains('selected'))
        exercise.hidden.push(v);
    }
    settings.exercises.push(exercise);
  }
  return settings;
}

function set_settings(settings)
{
  if (settings.version > 1)
    throw 'ERROR: Settings version too high.';
  // Int elements.
  for (let attribute of int_attributes)
    if (settings[attribute] !== undefined)
      document.getElementById(attribute).innerText = settings[attribute];
  // Rich text attributes.
  for (let attribute of rich_text_attributes)
    if (settings[attribute] !== undefined)
      document.getElementById(attribute).innerHTML = settings[attribute];
  // Exercises.
  document.getElementById('exercises').innerHTML = '';
  for (let exercise of settings.exercises)
    add_exercise(exercise, false);
  if (document.getElementById('exercises').getElementsByTagName('li').length == 0)
    add_exercise(undefined, false);

  settings_changed();
}

function settings_changed()
{
  // Enable generate button if there are exercises, disable otherwise.
  if (document.getElementById('exercises').getElementsByTagName('li').length)
    document.getElementById('generate').classList.remove('disabled');
  else
    document.getElementById('generate').classList.add('disabled');

  // Clear worksheets.
  document.getElementById('worksheet').innerHTML = '';

  let settings = JSON.stringify(get_settings());

  // Update local storage.
  window.localStorage.setItem('edu.math-worksheet-generator.settings', settings);

  // Update hash (without adding an entry to the history).
  window.history.replaceState(null, null, '#' + btoa(encodeURIComponent(settings)));
}

window.addEventListener('load', function()
{
  // Create settings.
  document.body.innerHTML = '';
  let exercise_operator_group = allocate_option_group();
  document.body.appendChild(
    create_element('div', {id: 'settings', classes: ['settings'], children:
    [
      create_element('h1', {children: 'Math Worksheet Generator'}),
      create_element('p', {children: [
        'Number of exercises per page: ',
        create_input_element({id: 'n_exercises', value: '100'}),
        '.',
      ]}),
      create_element('p', {children: [
        'Number of columns: ',
        create_input_element({id: 'n_columns', value: '4'}),
        '.',
      ]}),
      create_element('p', {children: [
        'Number of pages: ',
        create_input_element({id: 'n_pages', value: '1'}),
        '.',
      ]}),
      create_element('p', {children: ['Exercises (type: a operator b = c):']}),
      create_element('ul', {id: 'exercises'}),
      create_element('p', {children: [
        create_button({events: [{name: 'click', func: function(){ add_exercise(); }, bind: true}], children: ['add an exercise']}),
        create_button({children: ['show examples'], events: [{name: 'click', func: show_examples, bind: true}]}),
      ]}),
      create_element('p', {children: ['Header:']}),
      create_element('div', {id: 'headertext', contenteditable: true, children: [
        'Math Worksheet',
      ]}),
      create_element('p', {children: [
        create_button({id: 'generate', children: ['generate'], events: [{name: 'click', func: generate, bind: true}]}),
      ]}),
      create_element('p', {children: [
        create_checkbox({id: 'show_answers', events: [{name: 'change', func: update_show_answers}]}),
        ' Show answers.',
      ]}),
    ]}));
  document.body.appendChild(create_element('div', {id: 'worksheet'}));

  document.body.addEventListener('change', settings_changed);
  document.body.addEventListener('input', settings_changed);

  if (window.location.hash)
  {
    // Load settings from hash.
    try
    {
      set_settings(JSON.parse(decodeURIComponent(atob(window.location.hash.substring(1)))));
    }
    catch (e)
    {
      window.alert('invalid hash');
    }
  }
  else
  {
    // Load settings from hash.
    try
    {
      set_settings(JSON.parse(window.localStorage.getItem('edu.math-worksheet-generator.settings')));
    }
    catch (e)
    {
    }
  }
  if (document.getElementById('exercises').getElementsByTagName('li').length == 0)
    add_exercise(undefined, false);
});

// vim: sts=2:sw=2:et
